Introduction to Algorithms


第一部分 基础知识

	第一章 算法在计算中的作用

		1.1 算法
		算法描述一个特定的计算过程来实现输入输出关系

		1.2 作为一种技术的算法

	第二章 算法基础

		2.1 插入排序
		使用插入排序来排序手中扑克牌

		2.2 分析算法
		运行时间与输入规模

		2.3 设计算法
		2.3.1 分治法
		在归并排序中对小数组采用插入排序
		冒泡排序：反复交换相邻的未按次序排列的元素

	第三章 函数的增长
		3.1 渐进符号
		3.2 标准符号与常用函数

	第四章 分治策略

		分解+解决+合并
		使用递归式刻画分治算法的运行时间

		4.1 最大子数组问题
		寻找A的和最大的非空连续子数组。

		TIPS:数组的划分注意边界问题。接口越完善，扩展性越强。初始化一定要符合实际情况。

		4.2 矩阵乘法的Strassen算法
		https://www.cnblogs.com/zhoutaotao/p/3963048.html
		"""
		从实用的观点看，Strassen算法通常不是矩阵乘法所选择的方法：
		1. 在Strassen算法的运行时间中，隐含的常数因子比简单的O(n^3)方法常数因子大
		2. 当矩阵是稀疏的时候，为稀疏矩阵设计的算法更快
		3. Strassen算法不像简单方法那样子具有数值稳定性
		4. 在递归层次中生成的子矩阵要消耗空间。
		所以矩阵乘法一般意义上还是选择的是朴素的方法，只有当矩阵变稠密，而且矩阵的阶数>20左右，
		才会考虑使用Strassen算法。
		"""
		4.3 用代入法求解递归式
		4.4 用递归树法求解递归式
		4.5 用主方法求解递归式

	第五章 概率分析和随机算法

		5.1 雇用问题
		5.2 指示器随机变量(indicator random variable)
		5.3 随机算法


第二部分 排序和顺序统计量

	第六章 堆排序

		6.1 堆
		二叉堆可以分为两种形式：最大堆和最小堆。最大堆的某个结点的值最多与其父节点一样大。
		给定一个结点的下标i，得到父节点、左孩子和右孩子的下标：
		PARENT(i)
			return floor(i/2)
		LEFT(i)
			return 2i
		RIGHT(i)
			return 2i+1

		最大堆：
			A[PARENT(i)]>=A[i]
		MAX-HEAPIFY过程：时间复杂度O(lgn)，维护最大堆性质
		BUILD-MAX-HEAP:线性时间复杂度，从无序的输入数据数组中构造一个最大堆
		HEAPSORT:时间复杂度O(nlgn),对一个数组进行原址排序
		6.2 维护堆的性质
		TIPS:注意防止越界。

		6.3 建堆
		自底向上利用过程MAX_HEAPIFY转化为最大堆。
		6.4 堆排序算法

		6.5 优先队列
		优先队列(priority queue)是一种用来维护由一组元素构成的集合S的数据结构，其中每个元素都有一个相关的值，
		称为关键字(key)。一个最大优先队列支持以下操作：
		insert(S,x):把元素x插入到集合S中；
		maximum(S):返回S中具有最大键字的元素；
		extract_max(S):去掉并返回S中的具有最大键字的元素;
		increase_key(S,x,k):将元素x的关键字值增加到k，这里假设k的值不小于x的原关键字。

		过程HEAP_MAXIMUM可以在O(1)时间内实现maximum操作

	第七章 快速排序

		快速排序是一种最坏情况时间复杂度为O(n^2)的排序算法。但是平均性能特别好，期望时间复杂度是O(nlgn)，而且隐含的
		常数因子非常小。此外，能够进行原址排序。

		7.1 快速排序的描述

		7.2 快速排序的性能

		7.3 快速排序的随机化版本
		主元随机选取

		7.4 快速排序分析

	第八章 线性时间排序

	在排序的最终结果中，各元素之间的次序依赖于它们之间的比价：比较排序。

	8.1 排序算法的下界
		定理：在最坏情况下，任何比较排序算法都需要做O(nlgn)次比较
		定理：堆排序和归并排序都是渐进最优的比较排序算法。

		8.2 计数排序
		计数排序假设n个输入元素中的每一个都是在0到k区间内的一个整数。
		TIPS:注意分析变量取值，防止越界。

		8.3 基数排序
		radix sort
		TIPS:为了保证基数排序的正确性，一位数排序算法必须是稳定的。

		8.4 桶排序
		bucket sort
		桶排序假设输入由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上。
		平均情况下，时间代价为O(n)；

	第九章 中位数和顺序统计量

		在一个由n个元素组成的集合中，第i个顺序统计量(order statistic)是该集合中第i小的元素。
		输入：一个包含n个互异数的集合A和一个整数i,1<=i<=n；
		输出：元素x，A中恰好有i-1个其他元素小于它；

		9.1 最小值和最大值
		9.2 期望为线性时间的选择算法
		9.3 最坏情况为线性时间的选择算法

第三部分 数据结构

	第十章 基本数据结构

	10.1 栈和队列
		栈(stack)实现的是后进先出(LIFO);队列(queue)实现的是先进先出(FIFO)；

		栈上的INSERT操作称为压入(PUSH)，无元素参数的DELETE操作称为弹出(POP)

		10.2 链表
		linked list
		哨兵(sentinel)是一种哑对象，，作用是简化边界条件的处理。

		10.3 指针和对象的实现

		10.4 有根数的表示
		表示链表的方法可以推广到任意同构的数据结构上。

		二叉树：利用属性p,left,right存放指向父节点、左孩子和右孩子的指针。

	第十一章 散列表

		散列表(hash table，哈希表)是实现字典操作的一种有效数据结构；

		11.1 直接寻址表

		11.2 散列表

--这一部分不是特别清楚怎么回事啊？？--

	第十二章 二叉搜索树

	第十三章 红黑树

	第十四章 数据结构的扩张

第四部分 高级设计和分析技术
这一部分介绍了设计和分析高效算法的三种重要技术：动态规划、贪心算法和摊还分析；前三部分介绍了
其他一些广泛使用的技术：分治策略、随机化方法和递归技术。

	第十五章 动态规划
		dynamic programming
		常用来求解最优化问题(optimization problem)

		四个步骤设计一个动态规划算法：
		1. 刻画一个最优解的结构特征；					--建立数列
		2. 递归地定义最优解的值；					--建立数列
		3. 计算最优解的值，通常采用自底向上的方法；
		4. 利用计算出的信息构造一个最优解。

		15.1 钢条切割
		为了求解规模为n的原问题，先求解形式完全一样，但规模更小的子问题。
		满足最优子结构(optimal substructure)性质。问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。

		朴素递归算法之所以效率低(P221，自顶向上递归实现)，是因为它反复求解相同的子问题。因此，动态规划方法仔细安排求解顺序，
		对每个子问题只求一次解。

		动态规划有两种等价的实现方法：
			1. 带备忘的自顶向下法(top-dowm with memoization)
			2. 自底向上法(bottom-up method)

		子问题图：
		当思考一个动态规划问题时，应该弄清所涉及的子问题及子问题之间的依赖关系。

		15.2 矩阵链乘法
		矩阵链乘法问题(matrix-chain multiplication problem)：给定n个矩阵的链<A1, ..., An>，矩阵Ai
		的规模为p(i-1)xp(i)，求完全括号化方案，使得计算乘积所需标量乘法次数最少。

		---本质上是建立解的数列---
		---对数列的求解过程进行优化---

		15.3 动态规划原理
		具备两个要素：最优子结构和子问题重叠；

		如果一个问题的最优解包含其子问题的最优解，称此问题具有最优子结构性质；
		如果递归算法反复求解相同的子问题，称最优化问题具有重叠子问题性质；

		15.4 最长公共子序列

		15.5 最优二叉搜索树

	第十六章 贪心算法
		greedy algorithm

		16.1 活动选择问题

		活动选择问题的最优子结构
		贪心选择
		递归贪心算法

		16.2 贪心算法原理
		贪心算法通过做出一系列选择来求出问题的最优解。在每个决策点，它做出当时看来最佳的选择。

		1. 确定问题的最优子结构；
		2. 设计一个递归算法；
		3. 证明如果我们做出一个贪心选择，则只剩下一个子问题；
		4. 证明贪心选择总是安全的；
		5. 设计一个递归算法实现贪心策略；
		6. 将递归算法转换为迭代算法；

		贪心算法以动态规划方法为基础。

		贪心选择性质(greedy-choice property)：
		可以通过做出局部最优（贪心）选择来构造全局最优解。

		最优子结构：

		贪心对动态规划：
		都利用了最优子结构性质。
		0-1背包问题；
		分数背包问题；

		16.3 赫夫曼编码
		赫夫曼编码可以有效地压缩数据，通常可以节省20%~90%的空间。
		变长编码(variable-length code)可以达到比定长编码好得多的压缩率，其思想是赋予高频字符短码字，
		赋予低频字符长码字；

		前缀码(prefix code)，即没有任何码字是其他码字的前缀。

		定理：过程HUFFMAN会生成一个最优前缀码。

	第十七章 摊还分析

		17.1 聚合分析
		利用聚合分析，我们证明对所有n，一个n个操作的序列最坏情况下花费的总时间为T(n)。因此，在最坏情况下，
		每个操作的平均代价，或瘫痪代价为T(n)/n。

第五部分 高级数据结构

	第十八章 B树

	第十九章 斐波那契堆

	第二十章 van Emde Boas树

	第二十一章 用于不想交集合的数据结构

第六部分 图算法

	第二十二章 基本图算法

		22.1 图的表示
		对于图G=(V,E),其邻接链表表示由一个包含|V|条链表的数组Adj所构成，每个结点有一条链表。
		对于每个结点u∈V，邻接链表Adj[u]包含所有与结点u之间有边相连的结点v。

		表示图的属性

		22.2 广度优先搜索(Breadth First Search: BFS)
		给定图G=(V,E)和一个可以识别的源结点s,广度优先搜索对图G中的边进行系统性的探索来发现可以从源结点s到
		达的所有结点。该算法能够计算从源结点s到每个可达到的结点的距离（最少的边数），同时生成一颗“广度优先搜索树”。
		该树以源结点s为根结点，包含所有可以从s到达的结点。对于每个从源结点s可以到达的结点v，在广度优先搜索树里
		从结点s到结点v的简单路径所对应的就是图G中从结点s到结点v的“最短路径”，即包含最少边数的路径。该算法即可以用于
		有向图，也可以用于无向图。

		广度优先搜索之所以如此得名，是因为该算法始终是将已发现的结点和未发现结点之间的边界，沿其广度方向向外扩展。
		算法需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的其他结点。

		最短路径

		22.3 深度优先搜索

	第二十三章 最小生成树

		23.1 最小生成树的形成

	第二十四章 单源最短路径

	第二十五章 所有结点对的最短路径问题

	第二十六章 最大流

第七部分 算法问题选编

第二十七章 多线程算法

第二十八章 矩阵运算

第二十九章 线性规划

第三十章 多项式与快速傅里叶变换

第三十一章 数论算法

第三十二章 字符串匹配

第三十三章 计算几何学



