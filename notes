Introduction to Algorithms


第一部分 基础知识

第一章 算法在计算中的作用

1.1 算法
算法描述一个特定的计算过程来实现输入输出关系

1.2 作为一种技术的算法

第二章 算法基础

2.1 插入排序
使用插入排序来排序手中扑克牌

2.2 分析算法
运行时间与输入规模

2.3 设计算法
2.3.1 分治法
在归并排序中对小数组采用插入排序
冒泡排序：反复交换相邻的未按次序排列的元素

第三章 函数的增长
3.1 渐进符号
3.2 标准符号与常用函数

第四章 分治策略

分解+解决+合并
使用递归式刻画分治算法的运行时间

4.1 最大子数组问题
寻找A的和最大的非空连续子数组。

TIPS:数组的划分注意边界问题。接口越完善，扩展性越强。初始化一定要符合实际情况。

4.2 矩阵乘法的Strassen算法
https://www.cnblogs.com/zhoutaotao/p/3963048.html
"""
从实用的观点看，Strassen算法通常不是矩阵乘法所选择的方法：
1. 在Strassen算法的运行时间中，隐含的常数因子比简单的O(n^3)方法常数因子大
2. 当矩阵是稀疏的时候，为稀疏矩阵设计的算法更快
3. Strassen算法不像简单方法那样子具有数值稳定性
4. 在递归层次中生成的子矩阵要消耗空间。
所以矩阵乘法一般意义上还是选择的是朴素的方法，只有当矩阵变稠密，而且矩阵的阶数>20左右，
才会考虑使用Strassen算法。
"""
4.3 用代入法求解递归式
4.4 用递归树法求解递归式
4.5 用主方法求解递归式

第五章 概率分析和随机算法

5.1 雇用问题
5.2 指示器随机变量(indicator random variable)
5.3 随机算法


第二部分 排序和顺序统计量

第六章 堆排序

6.1 堆
二叉堆可以分为两种形式：最大堆和最小堆。最大堆的某个结点的值最多与其父节点一样大。
给定一个结点的下标i，得到父节点、左孩子和右孩子的下标：
PARENT(i)
	return floor(i/2)
LEFT(i)
	return 2i
RIGHT(i)
	return 2i+1

最大堆：
	A[PARENT(i)]>=A[i]
MAX-HEAPIFY过程：时间复杂度O(lgn)，维护最大堆性质
BUILD-MAX-HEAP:线性时间复杂度，从无序的输入数据数组中构造一个最大堆
HEAPSORT:时间复杂度O(nlgn),对一个数组进行原址排序
6.2 维护堆的性质
TIPS:注意防止越界。

6.3 建堆
自底向上利用过程MAX_HEAPIFY转化为最大堆。
6.4 堆排序算法

6.5 优先队列
优先队列(priority queue)是一种用来维护由一组元素构成的集合S的数据结构，其中每个元素都有一个相关的值，
称为关键字(key)。一个最大优先队列支持以下操作：
insert(S,x):把元素x插入到集合S中；
maximum(S):返回S中具有最大键字的元素；
extract_max(S):去掉并返回S中的具有最大键字的元素;
increase_key(S,x,k):将元素x的关键字值增加到k，这里假设k的值不小于x的原关键字。

过程HEAP_MAXIMUM可以在O(1)时间内实现maximum操作

第七章 快速排序

快速排序是一种最坏情况时间复杂度为O(n^2)的排序算法。但是平均性能特别好，期望时间复杂度是O(nlgn)，而且隐含的
常数因子非常小。此外，能够进行原址排序。

7.1 快速排序的描述

7.2 快速排序的性能

7.3 快速排序的随机化版本
主元随机选取

7.4 快速排序分析

第八章 线性时间排序

在排序的最终结果中，各元素之间的次序依赖于它们之间的比价：比较排序。

8.1 排序算法的下界
定理：在最坏情况下，任何比较排序算法都需要做O(nlgn)次比较
定理：堆排序和归并排序都是渐进最优的比较排序算法。

8.2 计数排序
计数排序假设n个输入元素中的每一个都是在0到k区间内的一个整数。
TIPS:注意分析变量取值，防止越界。

8.3 基数排序
radix sort


















